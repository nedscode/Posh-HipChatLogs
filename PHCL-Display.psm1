#
# Script file for module 'PoSh-HipChatLogs'
#
# Generated by: Nial Francis
#
# Generated on: 18/10/2019
#
# This script contains formatting and display/output to file functions

# Build an output object if required
## Select the relevant properties
## Write to disk
## Determine console no output or object output if not $LegacyFormat
# Output LegacyFormat
function OutputChat ($chatobj) {
	if ($AuditDirectory -or -not $NoConsoleLog) {
		if ($Highlight -or $HighlightIDs) {
			$props = ('Sender','Receiver','Time','Hit','Message')
		} else {
			$props = ('Sender','Receiver','Time','Message')
		}
		
		$displayobject = $chatobj | Select-Object -Property $props
		
		if ($AuditDirectory) {	
			$displayobject | Format-Table -AutoSize -Wrap | Out-String | Add-Content (Join-Path $AuditDirectory ($ParentDir + '.log'))
		}
		
		if ($NoConsoleLog) { return }
		elseif (-not $LegacyFormat) { $displayobject | Format-Table -AutoSize -Wrap }
	}
	
	if ($LegacyFormat) { OutputLegacyChat $chatobj }
}

# Legacy style print to console, line by line, closer to the original HipChat display
function OutputLegacyChat ($chatobj) {
	Write-Host "-----------------------------------------"
	foreach ( $indmsg in $chatobj ) {
		$meta = "{0} >> {1} - {2}" -f $indmsg.Sender,$indmsg.Receiver,$indmsg.Time.ToString('dd/MM/yyyy HH:mm:ss zzzz')
		if ($indmsg.Hit -ne $null) { $col = 'yellow' } else  { $col = 'white' }
		Write-Host $meta
		Write-Host -ForegroundColor $col $indmsg.message
	}
}

function Format-HipChatLogAsChat {
<#
.DESCRIPTION
	Accepts:
	- A json string from the user, or
	- A json file from the user, or
	- A data object from the Find-HipChatLog function.
	
	It then prepares the data and prints to console or saves to disk.
.SYNOPSIS
	Displays HipChat logs in a human-readable format.
.EXAMPLE
	Format-HipChatLogAsChat -FileName "C:\archive\users\1111\history.json" -Highlight '*find this text*'
	
	Reads FileName for the text "find this text" with wildcard matching.
	Displays the chat log as a table with messages containing "find this text" marked in the Hit column.
.NOTES
	The most useful way to parse the log files is if they are unchanged in the original archive export format from HipChat.
#>
[cmdletbinding()]
Param(
	[Parameter(ParameterSetName='Json')][string]$json,
	[Parameter(ParameterSetName='Object')][array]$LogObject,
	[Parameter(ParameterSetName='Object')][array]$HighlightIDs,
	[Parameter(ParameterSetName='File')][string]$FileName,
	[array]$Highlight,
	[string]$ParentDir = ([System.IO.FileInfo]$FileName).Directory.Name,
	[string]$AuditDirectory,
	[switch]$LegacyFormat,
	[switch]$NoConsoleLog,
	[switch]$Extract
)

	class HipChatMessage {
		[string]$Sender
		[string]$Receiver
		[datetime]$Time
		[string]$Message
		[string]$Hit
	}

	$privchatid = 0
	$extdmids = @()
	$alldmids = @()
	$messagelist = @{}
	
	if ($FileName) { Write-Verbose "Reading file"; $json = Get-Content -Raw $FileName }
	
	if ($json) {
		try {
			Add-Type -AssemblyName System.Web.Extensions
			$jss = New-Object -TypeName System.Web.Script.Serialization.JavaScriptSerializer
			$jss.MaxJsonLength = 1GB
			$data = $jss.Deserialize($json, [System.Object])
			Write-Verbose "Using .Net JavaScriptSerializer"
		} catch [System.TypeLoadException] {
			if ($PSVersionTable.PSEdition -eq 'Core') {
				throw "This module uses the JavaScriptSerializer from System.Web.Extensions.dll for better performance with large files.
				Try running under powershell.exe (not PowerShell Core). For more info see:
				https://docs.microsoft.com/en-us/dotnet/api/system.web.script.serialization.javascriptserializer?view=netframework-4.8".replace("`t",'')
			} else { throw $error[0] }
		}
	} else {
		Write-Verbose "Processing object"
		$data = $LogObject.Value
	}
	
	$objkeys = $data.Keys | Sort-Object -Unique
	
	# Foreach data type
	## Foreach message
	### Create a chat ID (either a room id or a unique user/user DM conversation id)
	### Build the display message object
	### Determine if there are any search terms in it
	foreach ($key in $objkeys) {
		foreach ($message in $data.$key) {
			if ($message.type -eq 'private') {
				$alldmids += $privchatid = $message.sender.id + $message.receiver.id
			} else { $alldmids += $privchatid = $ParentDir }
			
			$msg = New-Object HipChatMessage
			$msg.Sender		= ($message.sender.name, $message.type -ne $null)[0]
			$msg.Receiver	= ($message.receiver.name, "Room $ParentDir" -ne $null)[0]
			$msg.Time		= [datetime]$message.timestamp.split(' ')[0]
			$msg.Message	= (($message.attachment.url + $message.message),('<Message type: '+$message.type+'>') -ne ' ')[0]
			
			if ($HighlightIDs) {
				if ( $message.id -in $HighlightIDs ) {
					$msg.Hit = 'X'
					$extdmids += $privchatid
				}
			} elseif ($Highlight) {
				foreach ($term in $Highlight) {
					if ( $message.message -like "$term" ) {
						$msg.Hit = 'X'
						$extdmids += $privchatid
					}
				}
			}
			
			[array]$messagelist[$privchatid] += $msg
		}
	}
	
	# Only display chats with search terms
	# Or display all
	if ($Extract) {
		$extarr = $extdmids | Sort-Object -Unique
	} else {
		$extarr = $alldmids | Sort-Object -Unique
	}
	
	foreach ($eid in $extarr) {
		OutputChat ($messagelist[$eid] | Sort-Object Time)
	}
}